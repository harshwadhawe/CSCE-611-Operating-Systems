\documentclass{article}

\usepackage[english]{babel}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{MP7: Vanilla File System}
\author{Harsh Wadhawe\\UIN: 936001477\\CSCE611: Operating System}

\begin{document}

\date{}
\maketitle

\section*{Assigned Tasks}

\textbf{Main:} Completed. \\
\textbf{Bonus Option 1:} Completed. \\
\textbf{Bonus Option 2:} Completed. \\

\section*{System Design}

This implementation provides a simple file system supporting sequential file access with files identified by numeric IDs. The system consists of three core classes: \texttt{FileSystem}, \texttt{File}, and \texttt{Inode}.

\subsection*{Disk Layout}

The file system uses a simple three-part disk layout:

\begin{itemize}
    \item \textbf{Block 0 (INODES):} Contains the inode array storing metadata for all files
    \item \textbf{Block 1 (FREELIST):} Contains a byte-array bitmap tracking free/used blocks
    \item \textbf{Blocks 2+:} Data blocks for file content
\end{itemize}

\subsection*{File Size Support}

The implementation supports files up to 64kB (128 blocks of 512 bytes each) through the use of indirect blocks. This allows the inode structure to remain compact while supporting large files.

\subsection*{Indirect Block Architecture}

Instead of storing data block numbers directly in the inode, each file uses an indirect block:
\begin{itemize}
    \item The inode contains \texttt{block\_numbers\_block}, pointing to a block that stores an array of data block numbers
    \item This indirect block can store up to 128 block numbers (512 bytes / 4 bytes per block number)
    \item Data blocks are allocated on-demand as files grow, minimizing wasted space
\end{itemize}

\subsection*{Class Responsibilities}

\textbf{FileSystem Class:}
\begin{itemize}
    \item Manages file allocation and deallocation
    \item Maintains free-block bitmap
    \item Loads/saves inode list and free-block list to/from disk
    \item Provides file lookup, creation, and deletion
    \item Handles indirect block management
\end{itemize}

\textbf{File Class:}
\begin{itemize}
    \item Provides sequential read/write operations
    \item Maintains a single-block cache for efficiency
    \item Tracks current read/write position
    \item Handles multi-block reads and writes
    \item Manages block loading and writing
\end{itemize}

\textbf{Inode Structure:}
\begin{itemize}
    \item Stores file identifier (id)
    \item Points to indirect block containing data block numbers
    \item Tracks number of allocated blocks (num\_blocks)
    \item Stores current file length (file\_length)
    \item Contains pointer to FileSystem for disk access
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/inode_variables.png}
\caption{Inode structure showing indirect block architecture}
\end{figure}

\newpage
\section*{Code Description}

The implementation modifies four files: \texttt{file\_system.H}, \texttt{file\_system.C}, \texttt{file.H}, and \texttt{file.C}. Compilation uses the provided makefile with \texttt{make} in the MP7\_Sources directory.

\subsection*{FileSystem Implementation}

\paragraph{file\_system.H: Inode Structure}
The Inode class contains:
\begin{itemize}
    \item \texttt{long id}: File identifier (0 = unused inode)
    \item \texttt{unsigned int block\_numbers\_block}: Block number storing array of data block numbers (0 = invalid)
    \item \texttt{unsigned int num\_blocks}: Number of data blocks currently allocated
    \item \texttt{unsigned int file\_length}: Current file size in bytes (0-65536)
    \item \texttt{FileSystem* fs}: Pointer to file system for disk operations
    \item \texttt{static constexpr unsigned int MAX\_BLOCKS = 128}: Maximum blocks per file
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/inode_variables.png}
\caption{Inode structure definition with indirect block support}
\end{figure}

\paragraph{file\_system.C: FileSystem::FileSystem()}
Initializes all member variables to safe defaults:
\begin{itemize}
    \item Sets \texttt{disk}, \texttt{inodes}, and \texttt{free\_blocks} to \texttt{nullptr}
    \item Sets \texttt{size} to 0
    \item Keeps constructor simple as per design rationale
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/fs_constructor.png}
\caption{FileSystem constructor implementation}
\end{figure}

\paragraph{file\_system.C: FileSystem::\textasciitilde FileSystem()}
Ensures data persistence on unmount:
\begin{itemize}
    \item Saves inode list to Block 0 if mounted
    \item Saves free-block list to Block 1 if mounted
    \item Deallocates memory for inodes and free\_blocks arrays
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/fs_save_inodes_and_freelist.png}
\caption{FileSystem destructor saving inodes and free list}
\end{figure}

\paragraph{file\_system.C: FileSystem::Format()}
Creates an empty file system on disk:
\begin{itemize}
    \item Allocates temporary arrays for inodes and free blocks
    \item Initializes all inodes: id=0, block\_numbers\_block=0, num\_blocks=0, file\_length=0
    \item Marks blocks 0 and 1 as used (INODES and FREELIST)
    \item Marks all other blocks as free
    \item Writes both arrays to disk
    \item Deallocates temporary arrays
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/fs_format.png}
\caption{FileSystem::Format() implementation}
\end{figure}

\paragraph{file\_system.C: FileSystem::Mount()}
Associates file system with disk and loads metadata:
\begin{itemize}
    \item Stores disk pointer and calculates size
    \item Allocates inodes array (MAX\_INODES elements)
    \item Allocates free\_blocks array (one byte per block)
    \item Reads Block 0 into inodes array
    \item Reads Block 1 into free\_blocks array
    \item Sets fs pointer for all inodes
    \item Returns true on success
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/fs_mount.png}
\caption{FileSystem::Mount() implementation}
\end{figure}

\paragraph{file\_system.C: FileSystem::LookupFile()}
Searches for file by ID:
\begin{itemize}
    \item Iterates through inodes array
    \item Returns pointer to inode if id matches
    \item Returns \texttt{nullptr} if not found
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/fs_helper_get_free_inodes_and_blocks.png}
\caption{FileSystem::LookupFile() and helper functions}
\end{figure}

\paragraph{file\_system.C: FileSystem::CreateFile()}
Creates a new file:
\begin{itemize}
    \item Checks if file already exists (returns false if so)
    \item Finds free inode slot using \texttt{GetFreeInode()}
    \item Allocates one block for indirect block (block numbers array)
    \item Initializes indirect block to zeros
    \item Sets inode fields: id, block\_numbers\_block, num\_blocks=0, file\_length=0
    \item Marks indirect block as used in bitmap
    \item Saves inode list and free-block list to disk
    \item Returns true on success
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/fs_createfile.png}
\caption{FileSystem::CreateFile() implementation with indirect block allocation}
\end{figure}

\paragraph{file\_system.C: FileSystem::DeleteFile()}
Deletes a file and frees all blocks:
\begin{itemize}
    \item Looks up file using \texttt{LookupFile()}
    \item Reads indirect block to get array of data block numbers
    \item Marks all data blocks as free in bitmap
    \item Marks indirect block as free in bitmap
    \item Invalidates inode: sets id=0, block\_numbers\_block=0, num\_blocks=0, file\_length=0
    \item Saves inode list and free-block list to disk
    \item Returns true on success
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/fs_deletefile.png}
\caption{FileSystem::DeleteFile() implementation freeing all blocks}
\end{figure}

\paragraph{file\_system.C: Helper Functions}
\begin{itemize}
    \item \texttt{GetFreeInode()}: Finds first inode with id=0, returns index or -1
    \item \texttt{GetFreeBlock()}: Finds first free block starting from block 2, returns block number or -1
    \item \texttt{GetFreeBlocks()}: Allocates multiple free blocks (for future use)
    \item \texttt{SaveInodes()}: Writes inodes array to Block 0
    \item \texttt{SaveFreeList()}: Writes free\_blocks array to Block 1
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/fs_helper_get_free_inodes_and_blocks.png}
\caption{FileSystem helper functions: GetFreeInode() and GetFreeBlock()}
\end{figure}

\subsection*{File Implementation}

\paragraph{file.H: File Class Structure}
The File class contains:
\begin{itemize}
    \item \texttt{Inode* inode}: Pointer to file's inode
    \item \texttt{FileSystem* fs}: Pointer to file system
    \item \texttt{unsigned int current\_position}: Current read/write position
    \item \texttt{unsigned int cached\_block\_idx}: Index of currently cached block
    \item \texttt{unsigned char block\_cache[512]}: Single-block cache
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/inode_variables.png}
\caption{File class structure and relationship with Inode}
\end{figure}

\paragraph{file.C: File::File()}
Constructor initializes file handle:
\begin{itemize}
    \item Looks up inode using \texttt{fs->LookupFile()}
    \item Sets current\_position to 0
    \item Sets cached\_block\_idx to invalid value
    \item Initializes block\_cache to zeros
    \item Blocks are loaded on-demand during read/write operations
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/file_eof_reset.png}
\caption{File constructor and initialization}
\end{figure}

\paragraph{file.C: File::\textasciitilde File()}
Destructor ensures data persistence:
\begin{itemize}
    \item If a block is cached, writes it back to disk
    \item Reads indirect block to find correct data block number
    \item Writes cached block to appropriate data block
    \item Saves inode list to persist file length changes
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/file_eof_reset.png}
\caption{File destructor writing cached block to disk}
\end{figure}

\paragraph{file.C: File::Read()}
Reads data from file with multi-block support:
\begin{itemize}
    \item Calculates available bytes (file\_length - current\_position)
    \item Limits read to available bytes
    \item Loads block numbers from indirect block
    \item For each byte to read:
    \begin{itemize}
        \item Calculates which block contains the position
        \item Loads block into cache if not already cached
        \item Copies bytes from cache to buffer
        \item Handles reads spanning multiple blocks
    \end{itemize}
    \item Updates current\_position
    \item Returns number of bytes read
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/file_read.png}
\caption{File::Read() implementation with multi-block support}
\end{figure}

\paragraph{file.C: File::Write()}
Writes data to file with on-demand allocation:
\begin{itemize}
    \item Calculates maximum writable bytes (64kB limit - current\_position)
    \item Limits write to maximum
    \item Loads block numbers from indirect block
    \item For each byte to write:
    \begin{itemize}
        \item Calculates which block contains the position
        \item Allocates new block if needed (on-demand)
        \item Updates indirect block with new block number
        \item Loads block into cache if not already cached
        \item Copies bytes from buffer to cache
        \item Writes block back to disk immediately
    \end{itemize}
    \item Updates current\_position and file\_length
    \item Returns number of bytes written
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/file_write.png}
\caption{File::Write() implementation with on-demand block allocation}
\end{figure}

\paragraph{file.C: File::Reset()}
Resets file position to beginning:
\begin{itemize}
    \item Sets current\_position to 0
    \item Invalidates cache (sets cached\_block\_idx to invalid)
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/file_eof_reset.png}
\caption{File::Reset() and File::EoF() implementations}
\end{figure}

\paragraph{file.C: File::EoF()}
Checks if at end of file:
\begin{itemize}
    \item Returns true if current\_position >= file\_length
    \item Returns false otherwise
\end{itemize}


\section*{Bonus Option 1: Design for 64kB File Support}

\subsection*{Design Rationale}

The base implementation limited files to 512 bytes (one block). To support 64kB files (128 blocks), we needed to extend the allocation mechanism while keeping inodes compact enough to fit multiple inodes per block.

\subsection*{Design Solution: Indirect Blocks}

Instead of storing block numbers directly in the inode, we use a two-level structure:
\begin{itemize}
    \item \textbf{Inode} contains a pointer to an indirect block
    \item \textbf{Indirect block} stores an array of up to 128 data block numbers
    \item This keeps inode size small (fits multiple inodes per block) while supporting large files
\end{itemize}

\subsection*{Data Structure Changes}

\textbf{Inode Modifications:}
\begin{itemize}
    \item Replaced \texttt{block\_number} (single block) with \texttt{block\_numbers\_block} (pointer to indirect block)
    \item Added \texttt{num\_blocks} to track allocated blocks
    \item Increased \texttt{file\_length} maximum from 512 to 65536 bytes
    \item Added \texttt{MAX\_BLOCKS = 128} constant
\end{itemize}

\textbf{File Class Additions:}
\begin{itemize}
    \item Added \texttt{cached\_block\_idx} to track which block is currently cached
    \item Enables efficient block caching across multi-block operations
\end{itemize}

\subsection*{Allocation Strategy}

\textbf{On-Demand Allocation:}
\begin{itemize}
    \item Files start with only an indirect block allocated
    \item Data blocks are allocated only when needed during writes
    \item Prevents wasting disk space for small files
    \item Files grow dynamically up to 64kB limit
\end{itemize}

\textbf{Block Management:}
\begin{itemize}
    \item \texttt{CreateFile()}: Allocates one indirect block, initializes to zeros
    \item \texttt{Write()}: Allocates data blocks on-demand as file grows
    \item \texttt{DeleteFile()}: Frees indirect block and all referenced data blocks
\end{itemize}

\subsection*{Read/Write Operation Design}

\textbf{Read Operations:}
\begin{itemize}
    \item Load block numbers from indirect block
    \item Calculate which block contains current position
    \item Load block into cache if not already cached
    \item Handle reads spanning multiple blocks
    \item Respect file length boundary
\end{itemize}

\textbf{Write Operations:}
\begin{itemize}
    \item Load block numbers from indirect block
    \item Allocate new blocks on-demand as needed
    \item Update indirect block with new block numbers
    \item Handle writes spanning multiple blocks
    \item Update file length as data is written
    \item Enforce 64kB maximum limit
\end{itemize}

\subsection*{Functions Modified}

All FileSystem and File methods were updated to work with indirect blocks:
\begin{itemize}
    \item \texttt{Format()}: Initializes new inode structure
    \item \texttt{CreateFile()}: Allocates indirect block
    \item \texttt{DeleteFile()}: Frees indirect block and all data blocks
    \item \texttt{File::Read()}: Multi-block read with caching
    \item \texttt{File::Write()}: Multi-block write with on-demand allocation
    \item \texttt{File::Reset()}: Invalidates cache
\end{itemize}

\section*{Bonus Option 2: Implementation of 64kB File Support}

The design from Bonus Option 1 has been fully implemented. Key implementation details:

\subsection*{Indirect Block Management}

When a file is created, one block is allocated to store the array of data block numbers. This block can store 128 block numbers (512 bytes / 4 bytes per block number = 128 entries). The indirect block is initialized to zeros, and data block numbers are written to it as blocks are allocated.

\subsection*{On-Demand Block Allocation}

Data blocks are allocated only when needed during write operations. The \texttt{Write()} function:
\begin{itemize}
    \item Checks if a block exists for the current position
    \item If not, allocates a new block using \texttt{GetFreeBlock()}
    \item Writes the block number to the indirect block
    \item Updates \texttt{num\_blocks} in the inode
    \item Saves the updated indirect block to disk
\end{itemize}

This approach minimizes wasted disk space, as small files only use the blocks they need.

\subsection*{Block Caching Strategy}

The File class maintains a cache of one block at a time:
\begin{itemize}
    \item \texttt{cached\_block\_idx} tracks which block is currently in cache
    \item Blocks are loaded from disk only when needed
    \item Cache is invalidated when position changes significantly
    \item Modified blocks are written back to disk immediately during writes
    \item Cache is written back in destructor to ensure persistence
\end{itemize}

\subsection*{Multi-Block Read/Write}

Both read and write operations handle data spanning multiple blocks:
\begin{itemize}
    \item Calculate which block contains the current position
    \item Load the appropriate block into cache
    \item Copy data to/from cache
    \item Handle boundary crossing to next block
    \item Continue until all requested bytes are processed
\end{itemize}

\subsection*{Backward Compatibility}

The implementation maintains full backward compatibility with the existing test suite:
\begin{itemize}
    \item Small files (e.g., 20 bytes) work correctly
    \item Only one data block is allocated for small files
    \item Indirect block overhead is minimal
    \item All existing tests pass without modification
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/inode_variables.png}
\caption{Indirect block structure and multi-block file layout}
\end{figure}

\section*{Testing}

\textbf{This is a very important section!}

\subsection*{Test Methodology}

Testing was performed using the provided \texttt{exercise\_file\_system()} function in \texttt{kernel.C}. The test runs in a loop (30 iterations) and performs comprehensive file operations.

\subsection*{Test Procedure}

Each iteration performs:
\begin{enumerate}
    \item \textbf{File Creation}: Creates two files with IDs 1 and 2
    \item \textbf{File Opening}: Opens both files (constructors called)
    \item \textbf{File Writing}: Writes 20 characters to each file
    \item \textbf{File Closing}: Closes files (destructors write to disk)
    \item \textbf{File Reopening}: Opens files again
    \item \textbf{File Reading}: Resets position and reads 20 characters
    \item \textbf{Content Verification}: Verifies read data matches written data
    \item \textbf{File Deletion}: Deletes both files
    \item \textbf{Lookup Verification}: Verifies \texttt{LookupFile()} returns \texttt{nullptr}
\end{enumerate}

The test alternates between two different strings (STRING1 and STRING2) based on iteration number, ensuring data persistence works correctly across multiple cycles.

\subsection*{Test Results}

All 30 iterations completed successfully with "SUCCESS!!" messages. The final message "EXCELLENT! Your File system seems to work correctly. Congratulations!!" confirms all tests passed.

\subsection*{Test Coverage}

\textbf{What was tested:}
\begin{itemize}
    \item File creation and deletion
    \item Sequential write operations
    \item Sequential read operations
    \item File position tracking and reset
    \item Data persistence across open/close cycles
    \item File lookup functionality
    \item Multiple files operating simultaneously
    \item File system formatting and mounting
    \item Inode and free-block list management
    \item Indirect block allocation and deallocation
    \item Multi-block read/write operations (for bonus)
    \item On-demand block allocation (for bonus)
\end{itemize}

\textbf{What was not tested:}
\begin{itemize}
    \item Error handling for edge cases (duplicate file creation, deleting non-existent files)
    \item Writing files larger than 64kB (hitting the maximum limit)
    \item Reading beyond end of file (should return available bytes)
    \item File system with maximum number of files (all inodes used)
    \item File system with all blocks allocated (disk full scenario)
    \item Concurrent access (not applicable for this MP)
    \item Improper API usage (assumes intelligent user as per requirements)
\end{itemize}

\subsection*{Test Analysis}

The test suite provides good coverage of basic file operations and data persistence. The successful completion of all 30 iterations demonstrates:
\begin{itemize}
    \item Correct file allocation and deallocation
    \item Proper data persistence to disk
    \item Accurate file length tracking
    \item Correct multi-block read/write operations (bonus)
    \item Proper indirect block management (bonus)
    \item Reliable inode and free-block list synchronization
\end{itemize}

The implementation successfully handles the test scenarios and maintains data integrity across multiple file operations. The bonus implementation (64kB support) works seamlessly with the existing test suite, demonstrating backward compatibility while enabling large file support.

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/output_make_run.png}
\caption{Compilation and execution output}
\end{figure}

\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{figs/output_success.png}
\caption{Test execution showing successful completion of all iterations}
\end{figure}

\end{document}
